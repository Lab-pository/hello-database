## 트랜잭션 격리 레벨

트랜잭션이 동시에 변경을 수행하고 쿼리를 수행할 때 성능과 안정성, 일관성 및 결과 재현성 간의 균형을 미세 조정하는 설정이다. 트랜잭션이 동시에 수행될 때 다른 트랜잭션에서 변경하거나 조회하는 데이터를 어디까지 볼 수 있도록 허용할 것인지에 대한 설정

|                     | read uncommitted | read committed | repeatable read | serializable |
|---------------------|------------------|----------------|-----------------|--------------|
| dirty read          | 발생               | 없음             | 없음              | 없음           |
| non-repeatable read | 발생               | 발생             | 없음              | 없음           |
| phantom read        | 발생               | 발생             | 발생              | 없음           |

### Read Uncommitted

하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다. 이는 데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적이다.

- Dirty Read, Non-repeatable read, phantom read 모두 발생

### Read Committed

가장 많이 사용되는 격리 수준이다. 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋 완료된 데이터에 대해서만 조회를 허용한다.

- dirty read, dirty write 문제는 더 이상 발생하지 않는다.
- 하지만 non-Repeatable, phantom read와 같은 문제는 계속 발생한다.

### Repeatable Read

하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않는다.

### Serializable

말 그대로, 트랜잭션을 순차적으로 진행시키는 것을 말한다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다. 고립 수준이 Level 3으로 가장 높은 명령어로, 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게
분리된다.

## 격리 수준에 따른 문제점

### Dirty Read

### Non Repeatable Read

### Phantom Read



### Dirty Write

### Lost Update

### Read Skew

### Write Skew

## Reference

- https://stackoverflow.com/questions/73917534/read-skew-vs-non-repeatable-read-transaction
- https://stackoverflow.com/questions/27826714/lost-update-vs-write-skew
- https://stackoverflow.com/questions/72850415/isolation-level-difference-between-dirty-write-and-lost-update
